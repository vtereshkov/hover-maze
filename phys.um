import (
    "std.um"
    "mat.um"

    "input.um"

    "mazes.um"
)

type (
    State* = struct {
        pos, vel: mat::Vec
        rot: mat::Mat
        att, rate: mat::Vec
        collidingItem: ^mazes::StaticItem
    }

    Control = struct {
        force, moment: mat::Vec
    }
)

const (
    // Vehicle as a solid hemisphere
    mass            = 7000.0
    radius          = 3.0
    inertia         = 2.0 / 5.0 * mass * radius * radius

    force           = 150000.0
    moment          = 25000.0

    frictionForceFactor  = 10000.0
    frictionMomentFactor = 10000.0
)

fn project(pos: mat::Vec, line: [2]mat::Vec): (real, real) {
    pos[2] = 0.0
    line[0][2] = 0.0
    line[1][2] = 0.0

    relPos := pos.sub(line[0])

    lineDir := line[1].sub(line[0]).normalize()
    normalDir := mat::Vec{lineDir[1], -lineDir[0], 0.0}

    // relPos = proj * lineDir + dist * normalDir

    proj := relPos.dot(lineDir)
    dist := relPos.dot(normalDir)

    return proj, dist
}

fn (state: ^State) control(): Control {
    ctrl := Control{}

    if input::isPressed(.up)     {ctrl.force[0] =  force}
    if input::isPressed(.down)   {ctrl.force[0] = -force}
    if input::isPressed(.left)   {ctrl.moment[2] = -moment}
    if input::isPressed(.right)  {ctrl.moment[2] =  moment}

    return ctrl
}

fn (state: ^State) collide(maze: ^mazes::Maze, root: int = 0) {
    if root == -1 {
        return
    }

    if root == 0 {
        state.collidingItem = null
    }
    node := maze.bsp.items[root]

    line := [2]mat::Vec{mazes::fromMaze(node.line.start), mazes::fromMaze(node.line.end)}

    proj, dist := project(state.pos, line)

    if fabs(dist) < radius && proj >= 0.0 && proj <= line[1].sub(line[0]).norm() {
        item := &maze.static.items[node.indices.static]

        height := -state.pos[2]

        top    := -mazes::fromMaze({0, 0}, item.heights[0])[2]
        bottom := -mazes::fromMaze({0, 0}, item.heights[1])[2]

        if top < bottom {
            top, bottom = bottom, top
        }

        if !(top == bottom || height > top || height < bottom) {
            state.collidingItem = item
            return
        }
    }    

    if dist > -radius {
        // Vehicle is to the left or not too far to the right of the root item - traverse the left subtree
        state.collide(maze, node.indices.left)
    }

    if dist < radius {
        // Vehicle is to the right or not too far to the left of the root item - traverse the right subtree
        state.collide(maze, node.indices.right)
    }
}

fn (state: ^State) addImpactImpulse() {
    item := state.collidingItem

    if item == null {
        return
    }

    line := [2]mat::Vec{mazes::fromMaze(item.line.start, item.heights[0]), mazes::fromMaze(item.line.end, item.heights[0])}

    lineDir := line[1].sub(line[0]).normalize()
    normalDir := mat::Vec{lineDir[1], -lineDir[0], 0.0}

    if state.pos.sub(line[0]).dot(normalDir) < 0.0 {
        normalDir = normalDir.mul(-1.0)
    }

    normalVel := state.vel.dot(normalDir)
    if normalVel < 0.0 {
        state.vel = state.vel.sub(normalDir.mul(2.0 * normalVel))
    }
} 

fn (state: ^State) update*(dt: real, maze: ^mazes::Maze) {
    ctrl := state.control()

    frictionForce := state.vel.mul(-frictionForceFactor)
    frictionMoment := state.rate.mul(-frictionMomentFactor)

    state.collide(maze)
    state.addImpactImpulse()

    state.vel = state.vel.add(state.rot.mulv(ctrl.force).add(frictionForce).mul(dt / mass))
    state.pos = state.pos.add(state.vel.mul(dt))

    state.rate = state.rate.add(ctrl.moment.add(frictionMoment).mul(dt / inertia))
    state.rot = state.rot.add(state.rot.mulm(state.rate.toRateMat()).mul(dt)).normalize()

    state.att = state.rot.toAttAngles()
}

