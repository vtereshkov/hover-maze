import (
    "std.um"
    "mat.um"

    "image.um"
)

type (
    // Utilities

    Pos* = struct {
        x, y: int16
    }

    Line* = struct {
        start, end: Pos
    }

    Rect* = struct {
        min, max: Pos
    }

    String* = struct {
        data: str
    }

    LongString* = struct {
        dummy: [2]int16
        data: str
    }   

    // Static section

    StaticHeader* = struct {
        rect: Rect
        numItems: int16
        name: LongString    
    }

    StaticItem* = struct {
        name: String
        dummy2: int16
        line: Line
        dummy3: int16
        textures: [6]String
        heights: [2]int16
        flags: [16]uint8
        tiles: []Line        
        tileTexture: image::Image
    }

    Static* = struct {
        header: StaticHeader
        items: []StaticItem
    }

    // Location section

    LocationHeader* = struct {
        numItems: int16
        name: LongString        
    }

    LocationItem* = struct {
        name: String
        dummy2: int16
        pos: Pos
        flags2: [2]uint8
        height: int16
        flags: [4]uint8
    }

    Location* = struct {
        header: LocationHeader
        items: []LocationItem
    }

    // BSP section

    BSPHeader* = struct {
        name: LongString
    }

    BSPIndices* = struct {
        static, dummy2, left, right: int16
    }

    BSPItem* = struct {
        dummy2: [3]uint8
        line: Line
        dummy3: [2]uint8
        indices: BSPIndices
        dummy: [20]uint8
    }

    BSPSeparator = [2]uint8

    BSP* = struct {
        header: BSPHeader
        items: []BSPItem        
    }

    // Maze

    Maze* = struct {
        static: Static
        location: Location
        bsp: BSP
    }

    // Textures

    TexturePalette* = [256][4]uint8

    TextureHeader* = struct {
        palette: TexturePalette
        numItems: int16
        name: LongString
    }

    TextureBitmapHeader* = struct {
        width, maxX, height, maxY, logHeight, rawSize, dummy2: uint16 
    }

    TextureBitmapFooterItem* = struct {
        dummy: [2]int16 
    }       

    TextureScanlinePiece* = struct {
        from, to: int16
    }

    TextureScanline* = struct {
        pieces: []TextureScanlinePiece      
    }

    TextureBitmap* = struct {
        header: TextureBitmapHeader
        raw: []uint8
        numOfSomething: int16
        scanlines: []TextureScanline
        footer: []TextureBitmapFooterItem
    }

    TextureItem* = struct {
        name: String
        dummy: [2]int16
        bitmaps: []TextureBitmap
        dummy2: [2]uint8
    }

    Texture* = struct {
        header: TextureHeader
        items: []TextureItem
        itemTextures: map[struct {name: str; logScale: int}]image::Image
        backgroundTexture, dummyTexture: image::Image
    }
)

// Utilities

fn (this: ^String) read(f: std::File) {
    var length: uint8
    std::exitif(std::fread(f, &length).item1)

    chars := make([]char, length)
    std::exitif(std::fread(f, &chars).item1)

    this.data = chars
}

fn (this: ^LongString) read(f: std::File) {
    std::exitif(std::fread(f, &this.dummy).item1)

    var length: uint16
    std::exitif(std::fread(f, &length).item1)

    chars := make([]char, length)
    std::exitif(std::fread(f, &chars).item1)

    this.data = chars

    std::assert(this.dummy[0] == -1 && this.dummy[1] == 1)
}

fn (this: ^Line) length(): real {
    v := Pos{this.end.x - this.start.x, this.end.y - this.start.y}

    return sqrt(v.x * v.x + v.y * v.y)
}

fn (this: ^Pos) distFrom(line: Line): real {
    u := Pos{this.x - line.start.x, this.y - line.start.y}
    v := Pos{line.end.x - line.start.x, line.end.y - line.start.y}

    return (u.x * v.y - u.y * v.x) / sqrt(v.x * v.x + v.y * v.y)
}

// Static section

fn (this: ^StaticHeader) read(f: std::File) {
    std::exitif(std::fread(f, &this.rect).item1)
    std::exitif(std::fread(f, &this.numItems).item1)

    this.name.read(f)
    std::assert(this.name.data == "CMerlinStatic")
}

fn (this: ^StaticItem) read(f: std::File) {
    this.name.read(f)

    std::exitif(std::fread(f, &this.dummy2).item1)
    std::exitif(std::fread(f, &this.line).item1)
    std::exitif(std::fread(f, &this.dummy3).item1)

    for _, s^ in this.textures {
        s.read(f)
    }

    std::exitif(std::fread(f, &this.heights).item1)
    std::exitif(std::fread(f, &this.flags).item1)

    std::assert(this.dummy2 == 0 && this.dummy3 == 0)
}

fn (this: ^Static) read(f: std::File) {
    this.header.read(f)

    this.items = make([]StaticItem, this.header.numItems)
    for _, item^ in this.items {
        item.read(f)
    }       
}

// Location section

fn (this: ^LocationHeader) read(f: std::File) {
    std::exitif(std::fread(f, &this.numItems).item1)

    this.name.read(f)
    std::assert(this.name.data == "CMerlinLocation")
}

fn (this: ^LocationItem) read(f: std::File) {
    this.name.read(f)

    std::exitif(std::fread(f, &this.dummy2).item1)
    std::exitif(std::fread(f, &this.pos).item1)
    std::exitif(std::fread(f, &this.flags2).item1)
    std::exitif(std::fread(f, &this.height).item1)
    std::exitif(std::fread(f, &this.flags).item1)

    std::assert(this.dummy2 == 0)                   
}

fn (this: ^Location) read(f: std::File) {
    this.header.read(f)

    this.items = make([]LocationItem, this.header.numItems)
    for _, item^ in this.items {
        item.read(f)
    }       
}

// BSP section

fn (this: ^BSPHeader) read(f: std::File) {
    this.name.read(f)
    std::assert(this.name.data == "CMerlinBSP")
}

fn (this: ^BSPItem) read(f: std::File) {
    std::exitif(std::fread(f, &this.dummy2).item1)
    std::exitif(std::fread(f, &this.line).item1)
    std::exitif(std::fread(f, &this.dummy3).item1)
    std::exitif(std::fread(f, &this.indices).item1)
    std::exitif(std::fread(f, &this.dummy).item1)
}

fn (this: ^BSP) check(root: int16 = 0): int {
    node := this.items[root]
    count := 1

    if node.indices.left != -1 {
        child := this.items[node.indices.left]

        std::assert(child.line.start.distFrom(node.line) >= 0.0)
        std::assert(child.line.end.distFrom(node.line) >= 0.0)

        count += this.check(node.indices.left)
    }

    if node.indices.right != -1 {
        child := this.items[node.indices.right]

        std::assert(child.line.start.distFrom(node.line) <= 0.0)
        std::assert(child.line.end.distFrom(node.line) <= 0.0)

        count += this.check(node.indices.right)
    }

    return count        
}

fn (this: ^BSP) read(f: std::File) {
    this.header.read(f)

    for true {
        var item: BSPItem
        item.read(f)
        this.items = append(this.items, item)

        var separator: BSPSeparator
        _, err := std::fread(f, &separator)
        if std::StdErr(err.code) == .eof {
            break
        }   
    }

    std::assert(this.check() == len(this.items))        
}

// Maze

fn (this: ^Maze) read*(f: std::File) {
    this.static.read(f)
    this.location.read(f)
    this.bsp.read(f)
}

// Textures

fn (this: ^TextureHeader) read(f: std::File) {
    std::exitif(std::fread(f, &this.palette).item1)
    std::exitif(std::fread(f, &this.numItems).item1)
    this.name.read(f)
    std::assert(this.name.data == "CMerlinTexture")
}

fn (this: ^TextureScanline) read(f: std::File) {
    var length: int16
    std::exitif(std::fread(f, &length).item1)

    this.pieces = make([]TextureScanlinePiece, length)
    for _, piece^ in this.pieces {
        std::exitif(std::fread(f, piece).item1)
    }   
}

fn (this: ^TextureBitmap) actualRawSize(): int {
    return this.header.rawSize != 0 ? this.header.rawSize : this.header.width * this.header.height
}

fn (this: ^TextureBitmap) read(f: std::File) {
    std::exitif(std::fread(f, &this.header).item1)
    std::assert(this.header.height == 1 << this.header.logHeight)

    //printf("        header = %v\n", this.header)

    this.raw = make([]uint8, this.actualRawSize())
    std::exitif(std::fread(f, &this.raw).item1)

    std::exitif(std::fread(f, &this.numOfSomething).item1)

    this.scanlines = make([]TextureScanline, this.header.width)
    for _, scanline^ in this.scanlines {
        scanline.read(f)
    }

    var numFooterItems: int16
    std::exitif(std::fread(f, &numFooterItems).item1)

    this.footer = make([]TextureBitmapFooterItem, numFooterItems)
    for _, footerItem^ in this.footer {
        std::exitif(std::fread(f, footerItem).item1)
    }

    var dummy: int16
    std::exitif(std::fread(f, &dummy).item1)
}

fn (this: ^TextureBitmap) toImage(palette: ^TexturePalette, logScale: int): image::Image {
    imageData := make([]uint32, this.header.width * this.header.height)

    rawIndex := 0

    for x := 0; x < this.header.width; x++ {
        for _, piece in this.scanlines[x].pieces {
            for y := piece.from >> logScale; y <= piece.to >> logScale; y += 1 {
                color := palette[this.raw[rawIndex]]
                imageData[this.header.width * y + x] = (color[0] << 24) | (color[1] << 16) | (color[2] << 8) | 0xFF
                rawIndex++
            }
        }
    }

    image, err := image::mk(imageData, {this.header.width, this.header.height})
    std::exitif(err)

    return image
}

fn (this: ^TextureItem) read(f: std::File) {
    this.name.read(f)
    std::exitif(std::fread(f, &this.dummy).item1)

    //printf("%v %v\n", this.name, this.dummy)

    var numBitmaps: int16 
    std::exitif(std::fread(f, &numBitmaps).item1)

    this.bitmaps = make([]TextureBitmap, numBitmaps)
    for _, bitmap^ in this.bitmaps {
        bitmap.read(f)
    }

    std::exitif(std::fread(f, &this.dummy2).item1)
}

fn (this: ^Texture) read*(f: std::File) {
    this.header.read(f)

    this.items = make([]TextureItem, this.header.numItems)
    for _, item^ in this.items {
        item.read(f)
    }       
}

fn (this: ^Texture) getNamedTexture(name: str, logScale: int = 0): image::Image {
    if !this.dummyTexture.validate() {
        this.dummyTexture = image::mk({0x777777FF}, {1, 1}).item0
    }

    if name == "" {
        return this.dummyTexture
    }

    if !validkey(this.itemTextures, {name, logScale}) {
        for _, item^ in this.items {
            if name == item.name.data {
                image := item.bitmaps[logScale].toImage(&this.header.palette, logScale)
                this.itemTextures[{name, logScale}] = image
                return image
            }
        }
        return this.dummyTexture
    }

    return this.itemTextures[{name, logScale}]
}

fn (this: ^Texture) buildTiles*(item: ^StaticItem) {
    if len(item.tiles) > 0 {
        return
    }

    item.tileTexture = this.getNamedTexture(item.textures[2].data)
    if item.tileTexture == this.dummyTexture {
        item.tiles = append(item.tiles, item.line)
        return
    }

    itemDir := Pos{item.line.end.x - item.line.start.x, item.line.end.y - item.line.start.y}

    itemWidth := item.line.length()
    itemHeight := real(item.heights[1] - item.heights[0])

    if itemHeight == 0.0 {
        item.tiles = append(item.tiles, item.line)
        item.tileTexture = this.dummyTexture
        return
    }

    tileSize := item.tileTexture.getDims()

    tileScale := itemHeight / tileSize.y
    if tileScale < 1.0 {
        tileScale = 1.0
    }

    numTiles := round(itemWidth / (tileSize.x * tileScale))

    for i := 0; i < numTiles; i++ {      
        tile := Line{
            {
                item.line.start.x + itemDir.x * i / numTiles, 
                item.line.start.y + itemDir.y * i / numTiles
            },
            {
                item.line.start.x + itemDir.x * (i + 1) / numTiles, 
                item.line.start.y + itemDir.y * (i + 1) / numTiles
            },
        }
        item.tiles = append(item.tiles, tile)
    }
}

fn (this: ^Texture) getBackgroundTexture*(): image::Image {
    if this.backgroundTexture.validate() {
        return this.backgroundTexture
    }

    this.backgroundTexture = this.getNamedTexture("BACKGRND")
    return this.backgroundTexture
}

fn fromMaze*(pos: Pos, height: int16 = 0): mat::Vec {
    const mazeScale = 100.0
    return {-pos.y, pos.x, -height}.mul(1.0 / mazeScale)
} 